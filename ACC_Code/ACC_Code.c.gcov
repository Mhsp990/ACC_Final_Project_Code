        -:    0:Source:ACC_Code.c
        -:    0:Graph:Test_ACC.gcno
        -:    0:Data:Test_ACC.gcda
        -:    0:Runs:1
        -:    1:// ACC_code functions
        -:    2:#include <stdbool.h>
        -:    3:#include <stdio.h>
        -:    4:#include <stdlib.h>
        -:    5:
        -:    6:struct ACCenable {
        -:    7:  bool ACC_enabled;
        -:    8:  bool aux;
        -:    9:};
        -:   10:
        -:   11:struct ACCcontrol {
        -:   12:  float Acceleration;
        -:   13:  float Safe_distance;
        -:   14:};
        -:   15:
        -:   16://! ACC enable logic block
        -:   17:/*! This function has the role of checking whether or not it is possible to activate the ACC */
        -:   18:
       15:   19:struct ACCenable logicBlockAccEnable(bool aux/**<  Auxiliary variable */, 
        -:   20:                                     bool ACC_input/**<  ACC input is the variable that defines whether or not the user-defined ACC works */,
        -:   21:                                     bool Fault_signal/**< Fault signal is the variable that checks whether the sensors are working correctly */, 
        -:   22:                                     float Ego_velo/**< Ego velocity is the current speed of the vehicle*/,
        -:   23:                                     bool Gas_pedal/**< It is the variable that identifies whether the accelerator pedal is pressed*/, 
        -:   24:                                     bool Brake_pedal/**< It is the variable that identifies whether the brake pedal is pressed*/
        -:   25:                                     ) {
        -:   26:  struct ACCenable index;
        -:   27:
       15:   28:  if (aux == 0 && ACC_input == 1 && Fault_signal == 0 && Ego_velo >= 11 && Gas_pedal == 0 && Brake_pedal == 0) {
        2:   29:    index.aux = 1;
        2:   30:    index.ACC_enabled = 1;
        -:   31:
       13:   32:    }else if (ACC_input == 1 && aux == 1 && Fault_signal == 0 && Gas_pedal == 0 && Brake_pedal == 0) {
        2:   33:        index.ACC_enabled = 1;
        2:   34:        index.aux = 1;
        -:   35:      } else {
       11:   36:        index.ACC_enabled = 0;
       11:   37:        index.aux = 0;
        -:   38:      }
        -:   39:  
       15:   40:  return index;
        -:   41:}
        -:   42:
        -:   43://! Time Gap
        -:   44:/*! This function focuses on calculating the time gap between the car and the lead car */
        2:   45:float timeGap(bool Rain_sensor/**<  Variable that receives whether there is rain or not */) { 
        2:   46:  float Time_Gap = 3;
        2:   47:  const float Default_Time_Gap = 3;
        2:   48:  Time_Gap = Rain_sensor ? Default_Time_Gap * 2 : Default_Time_Gap;
        2:   49:  return Time_Gap;
        -:   50:}
        -:   51://! Speed Set
        -:   52:/*! This variable's function is to receive the desired speed value from the user and check whether it is possible to turn on the ACC by checking the speed range defined in the requirements.  */
        -:   53:
        3:   54:float speedSet(float ACC_speed_set/**<  Setspeed defined by user */) { 
        3:   55:  float ACC_speed_set_max = 120.0;
        3:   56:  float ACC_speed_set_min = 40.0;
        3:   57:  ACC_speed_set = (ACC_speed_set < ACC_speed_set_min) ?
        5:   58:  ACC_speed_set_min : (ACC_speed_set > ACC_speed_set_max) ? 
        2:   59:  ACC_speed_set_max : ACC_speed_set;
        3:   60:  return ACC_speed_set/3.6;
        -:   61:}
        -:   62:
        5:   63:struct ACCcontrol accelerationControl(bool ACC_enabled/**<  Variable that defines whether ACC is on or off */, 
        -:   64:                                      float Ego_velo/**<  Car speed */,
        -:   65:                                      float Time_Gap/**<  Time gap between ego car and lead car */, 
        -:   66:                                      float ACC_speed_set/**<  Setspeed defined by user */,
        -:   67:                                      float Relative_distance_past/**<  Relative distance past between ego car and lead car */, 
        -:   68:                                      float Relative_distance_pres/**<  Relative distance present between ego car and lead car */,
        -:   69:                                      float interval) {
        -:   70:  struct ACCcontrol i;
        -:   71:  //! Acceleration Control
        -:   72:  /*!
        -:   73:
        -:   74:  Function responsible for calculating and defining the acceleration to reach the setspeed or reduce the speed to meet the safety distance
        -:   75:  */
        5:   76:  float SafeD_relD                 = 0;    /*!<Difference between safe and relative distance  */
        5:   77:  const float D_default            = 10;   /*!<initial safe distance (at least) */
        5:   78:  float Control_x                  = 0;    /*!<Intermediate variable to calculate relative distance  */
        5:   79:  float Control_v                  = 0;    /*!<Intermediate variable to calculate relative distance  */
        5:   80:  const float Kverr_gain           = 0.5;  /*!<Model gain  */
        5:   81:  const float Kxerr_gain           = 0.5;  /*!<Model gain  */
        5:   82:  const float Kvx_gain             = 0.04; /*!<Model gain  */
        5:   83:  const float Ego_acceleration_min = -5;  /*!<Ego accleration maximum  */
        5:   84:  const float Ego_acceleration_max = 1.47; /*!<Ego accleration minimum  */
        5:   85:  float Relative_velo              = 0;    /*!<Relative velocity of both cars */
        -:   86:
        5:   87:  if (ACC_enabled) {// Test if acc is ON/OFF
        4:   88:    Relative_velo = (Relative_distance_pres - Relative_distance_past)/interval;
        4:   89:    i.Safe_distance = (Ego_velo * Time_Gap) + D_default;
        4:   90:    SafeD_relD = i.Safe_distance - Relative_distance_pres;
        4:   91:    Control_x = (Relative_velo * Kvx_gain) - ((i.Safe_distance - Relative_distance_pres) * Kxerr_gain);
        4:   92:    Control_v = (ACC_speed_set - Ego_velo) * Kverr_gain;
        -:   93:
        -:   94:
        -:   95:  // Test whether it is possible to use ACC safely
        4:   96:    if (SafeD_relD > 0) {
        2:   97:      i.Acceleration = (Relative_velo * Kvx_gain) - (SafeD_relD * Kxerr_gain);
        -:   98:
        -:   99:    } else {
        2:  100:      i.Acceleration = (Control_v < Control_x) ? Control_x : Control_v;
        -:  101:    }
        8:  102:    i.Acceleration = (i.Acceleration < Ego_acceleration_min) ?
        7:  103:    Ego_acceleration_min : (i.Acceleration > Ego_acceleration_max) ? 
        3:  104:    Ego_acceleration_max : i.Acceleration;
        4:  105:    return i;
        -:  106:    // If the safety conditions are not accepted, do not accelerate the car
        -:  107:  } else {
        1:  108:    i.Acceleration = 0;
        1:  109:    return i;
        -:  110:  }
        -:  111:}
